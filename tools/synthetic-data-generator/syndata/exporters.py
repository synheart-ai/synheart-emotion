"""Export synthetic data in various formats for different SDKs."""
import csv
import json
from pathlib import Path
from typing import Dict, List


def export_to_csv(data: List[Dict], output_path: str) -> None:
    """Export data to CSV format.

    Args:
        data: List of data points
        output_path: Output CSV file path
    """
    if not data:
        return

    with open(output_path, "w", newline="") as f:
        # Flatten RR intervals for CSV
        fieldnames = ["timestamp", "hr", "emotion", "scenario", "rr_intervals"]
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()

        for point in data:
            row = {
                "timestamp": point["timestamp"].isoformat(),
                "hr": point["hr"],
                "emotion": point["emotion"],
                "scenario": point["scenario"],
                "rr_intervals": ",".join(str(x) for x in point["rr_intervals_ms"]),
            }
            writer.writerow(row)


def export_to_json(data: List[Dict], output_path: str, pretty: bool = True) -> None:
    """Export data to JSON format.

    Args:
        data: List of data points
        output_path: Output JSON file path
        pretty: Use pretty printing (indented)
    """
    # Convert datetime to ISO format
    json_data = []
    for point in data:
        json_point = {
            "timestamp": point["timestamp"].isoformat(),
            "hr": point["hr"],
            "rr_intervals_ms": point["rr_intervals_ms"],
            "emotion": point["emotion"],
            "scenario": point["scenario"],
        }
        json_data.append(json_point)

    with open(output_path, "w") as f:
        if pretty:
            json.dump(json_data, f, indent=2)
        else:
            json.dump(json_data, f)


def export_to_python(data: List[Dict], output_path: str) -> None:
    """Export data as Python code for testing Python SDK.

    Args:
        data: List of data points
        output_path: Output Python file path
    """
    with open(output_path, "w") as f:
        f.write('"""Generated synthetic biosignal data for testing."""\n')
        f.write("from datetime import datetime\n\n")
        f.write("# Test data generated by syndata\n")
        f.write("# Can be used directly with synheart_emotion SDK\n\n")
        f.write("test_data = [\n")

        for i, point in enumerate(data):
            f.write("    {\n")
            f.write(f'        "timestamp": datetime.fromisoformat("{point["timestamp"].isoformat()}"),\n')
            f.write(f'        "hr": {point["hr"]:.2f},\n')
            f.write(f'        "rr_intervals_ms": {point["rr_intervals_ms"]},\n')
            f.write(f'        "emotion": "{point["emotion"]}",\n')
            f.write(f'        "scenario": "{point["scenario"]}",\n')
            f.write("    },\n")

        f.write("]\n\n")
        f.write("# Example usage:\n")
        f.write("# from synheart_emotion import EmotionEngine, EmotionConfig\n")
        f.write("# engine = EmotionEngine.from_pretrained(EmotionConfig())\n")
        f.write("# for point in test_data:\n")
        f.write("#     engine.push(\n")
        f.write("#         hr=point['hr'],\n")
        f.write("#         rr_intervals_ms=point['rr_intervals_ms'],\n")
        f.write("#         timestamp=point['timestamp']\n")
        f.write("#     )\n")
        f.write("#     results = engine.consume_ready()\n")


def export_to_kotlin(data: List[Dict], output_path: str) -> None:
    """Export data as Kotlin code for testing Android SDK.

    Args:
        data: List of data points
        output_path: Output Kotlin file path
    """
    with open(output_path, "w") as f:
        f.write("package com.synheart.emotion.testdata\n\n")
        f.write("import java.util.Date\n")
        f.write("import java.text.SimpleDateFormat\n\n")
        f.write("/**\n")
        f.write(" * Generated synthetic biosignal data for testing.\n")
        f.write(" * Can be used directly with Synheart Emotion SDK.\n")
        f.write(" */\n")
        f.write("object TestData {\n")
        f.write('    private val dateFormat = SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSSSSS")\n\n')
        f.write("    data class DataPoint(\n")
        f.write("        val timestamp: Date,\n")
        f.write("        val hr: Double,\n")
        f.write("        val rrIntervalsMs: List<Double>,\n")
        f.write("        val emotion: String,\n")
        f.write("        val scenario: String\n")
        f.write("    )\n\n")
        f.write("    val testData = listOf(\n")

        for i, point in enumerate(data):
            timestamp_str = point["timestamp"].strftime("%Y-%m-%dT%H:%M:%S.%f")
            rr_list = ", ".join(f"{x:.1f}" for x in point["rr_intervals_ms"])

            f.write("        DataPoint(\n")
            f.write(f'            timestamp = dateFormat.parse("{timestamp_str}")!!,\n')
            f.write(f'            hr = {point["hr"]:.2f},\n')
            f.write(f"            rrIntervalsMs = listOf({rr_list}),\n")
            f.write(f'            emotion = "{point["emotion"]}",\n')
            f.write(f'            scenario = "{point["scenario"]}"\n')
            f.write("        ),\n")

        f.write("    )\n\n")
        f.write("    // Example usage:\n")
        f.write("    // val config = EmotionConfig()\n")
        f.write("    // val engine = EmotionEngine.fromPretrained(config)\n")
        f.write("    // for (point in testData) {\n")
        f.write("    //     engine.push(\n")
        f.write("    //         hr = point.hr,\n")
        f.write("    //         rrIntervalsMs = point.rrIntervalsMs,\n")
        f.write("    //         timestamp = point.timestamp\n")
        f.write("    //     )\n")
        f.write("    //     val results = engine.consumeReady()\n")
        f.write("    // }\n")
        f.write("}\n")


def export_to_swift(data: List[Dict], output_path: str) -> None:
    """Export data as Swift code for testing iOS SDK.

    Args:
        data: List of data points
        output_path: Output Swift file path
    """
    with open(output_path, "w") as f:
        f.write("import Foundation\n\n")
        f.write("/// Generated synthetic biosignal data for testing.\n")
        f.write("/// Can be used directly with Synheart Emotion SDK.\n")
        f.write("struct TestDataPoint {\n")
        f.write("    let timestamp: Date\n")
        f.write("    let hr: Double\n")
        f.write("    let rrIntervalsMs: [Double]\n")
        f.write("    let emotion: String\n")
        f.write("    let scenario: String\n")
        f.write("}\n\n")
        f.write("let testData: [TestDataPoint] = [\n")

        for i, point in enumerate(data):
            # Swift Date from ISO8601 string
            timestamp_str = point["timestamp"].isoformat()
            rr_list = ", ".join(f"{x:.1f}" for x in point["rr_intervals_ms"])

            f.write("    TestDataPoint(\n")
            f.write(f'        timestamp: ISO8601DateFormatter().date(from: "{timestamp_str}")!,\n')
            f.write(f"        hr: {point['hr']:.2f},\n")
            f.write(f"        rrIntervalsMs: [{rr_list}],\n")
            f.write(f'        emotion: "{point["emotion"]}",\n')
            f.write(f'        scenario: "{point["scenario"]}"\n')
            f.write("    ),\n")

        f.write("]\n\n")
        f.write("// Example usage:\n")
        f.write("// let config = EmotionConfig()\n")
        f.write("// let engine = try! EmotionEngine.fromPretrained(config: config)\n")
        f.write("// for point in testData {\n")
        f.write("//     engine.push(\n")
        f.write("//         hr: point.hr,\n")
        f.write("//         rrIntervalsMs: point.rrIntervalsMs,\n")
        f.write("//         timestamp: point.timestamp\n")
        f.write("//     )\n")
        f.write("//     let results = engine.consumeReady()\n")
        f.write("// }\n")


def export_all_formats(data: List[Dict], output_dir: str, basename: str = "test_data") -> Dict[str, str]:
    """Export data in all supported formats.

    Args:
        data: List of data points
        output_dir: Output directory
        basename: Base name for output files

    Returns:
        Dictionary mapping format name to output file path
    """
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)

    outputs = {}

    # CSV
    csv_path = output_path / f"{basename}.csv"
    export_to_csv(data, str(csv_path))
    outputs["csv"] = str(csv_path)

    # JSON
    json_path = output_path / f"{basename}.json"
    export_to_json(data, str(json_path))
    outputs["json"] = str(json_path)

    # Python
    py_path = output_path / f"{basename}.py"
    export_to_python(data, str(py_path))
    outputs["python"] = str(py_path)

    # Kotlin
    kt_path = output_path / f"{basename}.kt"
    export_to_kotlin(data, str(kt_path))
    outputs["kotlin"] = str(kt_path)

    # Swift
    swift_path = output_path / f"{basename}.swift"
    export_to_swift(data, str(swift_path))
    outputs["swift"] = str(swift_path)

    return outputs
